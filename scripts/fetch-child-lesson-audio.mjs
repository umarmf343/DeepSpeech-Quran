#!/usr/bin/env node

import fs from "node:fs/promises"
import path from "node:path"
import { fileURLToPath } from "node:url"
import { execFile } from "node:child_process"
import { promisify } from "node:util"
import googleTTS from "google-tts-api"
import ffmpegPath from "ffmpeg-static"

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const projectRoot = path.resolve(__dirname, "..")
const outputDir = path.join(projectRoot, "public", "audio", "child-lessons")
const generatedTsPath = path.join(
  projectRoot,
  "lib",
  "child-class",
  "lesson-audio-data.ts",
)
const sourcePath = path.join(__dirname, "letter-lesson-text.json")

const execFileAsync = promisify(execFile)
const FALLBACK_BUFFER_FLAG = Symbol("fallbackTone")

const createFallbackTone = async () => {
  if (!ffmpegPath) {
    console.warn("ffmpeg binary not available â€“ unable to synthesize fallback audio")
    return null
  }

  try {
    const { stdout } = await execFileAsync(
      ffmpegPath,
      [
        "-loglevel",
        "error",
        "-f",
        "lavfi",
        "-i",
        "sine=frequency=660:duration=1",
        "-ac",
        "1",
        "-ar",
        "22050",
        "-b:a",
        "96k",
        "-f",
        "mp3",
        "pipe:1",
      ],
      { encoding: "buffer", maxBuffer: 1024 * 1024 },
    )

    stdout[FALLBACK_BUFFER_FLAG] = true

    return stdout
  } catch (error) {
    console.warn("Unable to synthesize fallback audio", error)
    return null
  }
}

let fallbackTonePromise

const loadFallbackTone = async () => {
  if (!fallbackTonePromise) {
    fallbackTonePromise = createFallbackTone()
  }

  return fallbackTonePromise
}

const ensureDirectory = async (dirPath) => {
  await fs.mkdir(dirPath, { recursive: true })
}

const shouldForce = process.argv.includes("--force")

const readLessonText = async () => {
  const raw = await fs.readFile(sourcePath, "utf8")
  const data = JSON.parse(raw)
  if (!Array.isArray(data)) {
    throw new Error("letter-lesson-text.json must contain an array of lessons")
  }
  return data
}

const fileExists = async (filePath) => {
  try {
    await fs.access(filePath)
    return true
  } catch {
    return false
  }
}

const writeFileIfMissing = async (filePath, data) => {
  if (!shouldForce) {
    try {
      await fs.access(filePath)
      return false
    } catch {}
  }

  await fs.writeFile(filePath, data)
  return true
}

const emitTypeScriptModule = async (buffersById) => {
  const sortedEntries = [...buffersById.entries()].sort((a, b) => a[0] - b[0])
  const lines = [
    "// This file is auto-generated by scripts/fetch-child-lesson-audio.mjs",
    "// Do not edit this file directly.",
    "/* eslint-disable */",
    "export const LESSON_AUDIO_DATA: Record<number, string> = {",
  ]

  for (const [id, buffer] of sortedEntries) {
    const base64 = buffer.toString("base64")
    lines.push(`  ${id}: "${base64}",`)
  }

  lines.push("}", "")

  await fs.writeFile(generatedTsPath, lines.join("\n"), "utf8")
}

const fetchAudioForText = async (text) => {
  const trimmed = text?.toString().normalize("NFC").trim()
  if (!trimmed) {
    return null
  }

  let chunks
  try {
    chunks = googleTTS.getAllAudioUrls(trimmed, {
      lang: "ar",
      slow: false,
      host: "https://translate.google.com",
    })
  } catch (error) {
    console.warn(`Failed to generate TTS request for "${trimmed}"`, error)
    return loadFallbackTone()
  }

  if (!Array.isArray(chunks) || chunks.length === 0) {
    console.warn(`No audio chunks returned for "${trimmed}", using synthesized tone`)
    return loadFallbackTone()
  }

  for (const chunk of chunks) {
    try {
      const response = await fetch(chunk.url)
      if (!response.ok) {
        console.warn(`TTS request failed with status ${response.status} for "${trimmed}"`)
        continue
      }

      const arrayBuffer = await response.arrayBuffer()
      return Buffer.from(arrayBuffer)
    } catch (error) {
      console.warn(`Network error fetching audio for "${trimmed}"`, error)
    }
  }

  return loadFallbackTone()
}

const main = async () => {
  await ensureDirectory(outputDir)
  const lessons = await readLessonText()
  const existingByText = new Map()
  let downloaded = 0
  let reused = 0
  const buffersById = new Map()

  for (const lesson of lessons) {
    const { id, text, title } = lesson
    if (!id) {
      console.warn("Skipping lesson with missing id", lesson)
      continue
    }

    const normalized = text?.toString().normalize("NFC").trim()
    const destination = path.join(outputDir, `${id}`)

    if (!normalized) {
      console.warn(`Skipping lesson ${id} (${title}) because it has no text`)
      continue
    }

    if (existingByText.has(normalized)) {
      const sourceBuffer = existingByText.get(normalized)
      buffersById.set(id, sourceBuffer)
      const created = await writeFileIfMissing(destination, sourceBuffer)
      if (created) {
        reused++
        console.log(`Reused audio for lesson ${id} (${title})`)
      }
      continue
    }

    if (!shouldForce && (await fileExists(destination))) {
      const buffer = await fs.readFile(destination)
      existingByText.set(normalized, buffer)
      buffersById.set(id, buffer)
      reused++
      console.log(`Audio already exists for lesson ${id} (${title})`)
      continue
    }

    const buffer = await fetchAudioForText(normalized)
    if (!buffer) {
      console.warn(`No audio generated for lesson ${id} (${title})`)
      continue
    }

    const isFallback = Boolean(buffer[FALLBACK_BUFFER_FLAG])
    existingByText.set(normalized, buffer)
    buffersById.set(id, buffer)
    const created = await writeFileIfMissing(destination, buffer)
    if (created) {
      downloaded++
      const verb = isFallback ? "Synthesized" : "Downloaded"
      console.log(`${verb} audio for lesson ${id} (${title})`)
    } else {
      if (!shouldForce) {
        reused++
        console.log(`Audio already exists for lesson ${id} (${title})`)
      } else {
        downloaded++
        const verb = isFallback ? "Resynthesized" : "Refreshed"
        console.log(`${verb} audio for lesson ${id} (${title})`)
      }
    }
  }

  await emitTypeScriptModule(buffersById)

  console.log(
    `\nAudio fetch complete. Downloaded: ${downloaded}, reused: ${reused}. Files saved to ${outputDir}`,
  )
  console.log(`Generated TypeScript module at ${generatedTsPath}`)
}

main().catch((error) => {
  console.error(error)
  process.exitCode = 1
})
